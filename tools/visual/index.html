<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="app.js"></script>
    <link rel="icon" type="image/jpeg" href="California_sea_lion_in_La_Jolla_(70568).jpg" />
    <style>
        table {
            border-collapse: collapse;
            width: 100%;
        }
        
        th,
        td {
            border: 1px solid black;
            padding: 4px;
        }
        
        .scroll-box {
            height: 200px;
            /* Set the height of the scrollable area */
            width: 300px;
            /* Set the width */
            overflow-y: scroll;
            /* Enable vertical scrolling */
            border: 1px solid #ccc;
            /* Optional: Add a border */
        }
    </style>
</head>

<body>

    <h1>
        GBA Emulator
        <input type="text" placeholder="Snapshot" id="snapshotNum" />
    </h1>

    <h2>BitUtils</h2>
    <div>
        <input type="text" placeholder="Hex" id="hexInput" />
        <div>
            <table id="binOutputTable">
            </table>
        </div>
    </div>

    <h2>Pipeline</h2>
    <table id="pipelineTable"></table>

    <h2>Registers</h2>
    <table id="registersTable"></table>

    <h2>Memory</h2>
    <h3>
        BIOS
        <input type="text" placeholder="Start address" id="biosStartAddrInput" />
        <input type="text" placeholder="End address" id="biosEndAddrInput" />
    </h3>
    <div class="scroll-box">
        <table id="memoryBIOSTable">
        </table>
    </div>
    <h3>
        WRAM On Board
        <input type="text" placeholder="Start address" id="WRAMOnBoardStartAddrInput" />
        <input type="text" placeholder="End address" id="WRAMOnBoardEndAddrInput" />
    </h3>
    <div class="scroll-box">
        <table id="memoryWRAMOnBoardTable">
        </table>
    </div>

    <script>
        // Initialization
        let memory;
        let registers;
        let pipeline;
        load_registers(0);
        load_memory(0);
        load_pipeline(0);

        function load_pipeline(snapshotNum_) {
            ReadPipelineData(snapshotNum_).then((pipeline_data) => {
                console.log("Read pipeline");
                pipeline = pipeline_data;

                update_pipeline();
            });
        }

        function load_registers(snapshotNum_) {
            ReadRegisterData(snapshotNum_).then((registers_data) => {
                console.log("Read registers");
                registers = registers_data;

                update_registers();
            });
        }

        function load_memory(snapshotNum_) {
            ReadMemoryData(snapshotNum_).then((memory_data) => {
                console.log("Read memory");
                memory = memory_data;
            });
        }

        function update_pipeline() {
            const table_element = document.getElementById("pipelineTable");
            table_element.innerHTML = "";
            let tr = document.createElement("tr");
            let trh = document.createElement("tr");
            for (const key in pipeline) {
                const td = document.createElement("td");
                const tdh = document.createElement("td");
                tdh.textContent = key;
                td.textContent = toHex(pipeline[key]);
                tr.appendChild(td);
                trh.appendChild(tdh);
            }
            table_element.appendChild(trh);
            table_element.appendChild(tr);
        }

        function update_registers() {
            console.log("Decoded registers:", registers);

            const flat_registers = Object.entries(registers).map(
                ([key, value]) => `${key}: ${toHex(value)}`
            );

            const num_cols = 4;
            let table = [];
            for (let i = 0; i < flat_registers.length; i += num_cols) {
                table.push(flat_registers.slice(i, i + num_cols));
            }
            console.log("table", table);

            const table_element = document.getElementById("registersTable");
            table_element.innerHTML = "";
            for (let i = 0; i < table.length; ++i) {
                let tr = document.createElement("tr");
                for (let j = 0; j < table[i].length; j++) {
                    const td = document.createElement("td");
                    td.textContent = table[i][j];
                    tr.appendChild(td);
                }
                table_element.appendChild(tr);
            }
        }

        function update_memory_segment(memory_segment, start_addr, start_input, end_input, table) {
            const flat_memory = memory_segment;
            const table_element = document.getElementById(table);
            table_element.innerHTML = "";

            let StartAddrInput = Math.max(parseInt(document.getElementById(start_input).value) - start_addr, 0);
            let EndAddrInput = Math.max(StartAddrInput, Math.min(parseInt(document.getElementById(end_input).value) - start_addr, flat_memory.length - 1));

            console.log(StartAddrInput);
            console.log(EndAddrInput);
            console.log(flat_memory.length);

            for (let i = EndAddrInput; i >= StartAddrInput; --i) {
                let tr = document.createElement("tr");

                const td1 = document.createElement("td");
                td1.textContent = toHex(i + start_addr);
                const td2 = document.createElement("td");
                td2.textContent = toHex(flat_memory[i]);
                tr.appendChild(td1);
                tr.appendChild(td2);

                table_element.appendChild(tr);
            }
        }

        function update_memory() {
            update_memory_segment(
                memory.BIOS,
                memory.BIOS_index,
                "biosStartAddrInput",
                "biosEndAddrInput",
                "memoryBIOSTable");
            update_memory_segment(
                memory.wram_on_board,
                memory.wram_on_board_index,
                "WRAMOnBoardStartAddrInput",
                "WRAMOnBoardEndAddrInput",
                "memoryWRAMOnBoardTable");
        }

        document.getElementById("biosStartAddrInput").addEventListener("input", function(event) {
            update_memory();
        });

        document.getElementById("biosEndAddrInput").addEventListener("input", function(event) {
            update_memory();
        });

        document.getElementById("WRAMOnBoardStartAddrInput").addEventListener("input", function(event) {
            update_memory();
        });

        document.getElementById("WRAMOnBoardEndAddrInput").addEventListener("input", function(event) {
            update_memory();
        });

        document.getElementById("snapshotNum").addEventListener("input", function(event) {
            const snapshotNum = parseInt(event.target.value) || 0;
            load_registers(snapshotNum);
            load_memory(snapshotNum);
            load_pipeline(snapshotNum);
        });

        document.getElementById("hexInput").addEventListener("input", function(event) {
            let bin_output_table = document.getElementById("binOutputTable");
            bin_output_table.innerHTML = "";
            bin_string = toBinary(parseInt(event.target.value)).slice(2);
            let tr = document.createElement("tr");
            let trh = document.createElement("tr");
            for (let i = 0; i < bin_string.length; ++i) {
                const td = document.createElement("td");
                const tdh = document.createElement("td");
                td.textContent = bin_string[i];
                tdh.textContent = bin_string.length - i - 1;

                td.style.width = "20px";
                td.style.textAlign = "center";

                tdh.style.width = "20px";
                tdh.style.textAlign = "center";

                const lightColors = [
                    "#FFB3BA", // Light Red/Pink
                    "#FFDFBA", // Light Orange
                    "#FFFFBA", // Light Yellow
                    "#BAFFC9", // Light Green
                    "#BAE1FF", // Light Blue
                    "#D6BAFF", // Light Purple
                    "#FFE1BA", // Light Peach
                    "#BAFFF9" // Light Cyan
                ];

                td.style.backgroundColor = lightColors[Math.floor(i / 4)];
                tdh.style.backgroundColor = lightColors[Math.floor(i / 4)];

                tr.appendChild(td);
                trh.appendChild(tdh)
            }
            bin_output_table.appendChild(trh);
            bin_output_table.appendChild(tr);
        });
    </script>

</body>

</html>